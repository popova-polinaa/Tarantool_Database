# Tarantool_Database
Короткий драфт по решению с описанием требований к реализации функции прогрева данных для платформы Tarantool.
## Содержание
### [1. Требования к реализации функции прогрева данных](#first)
### [2. Анализ реализации функции прогрева данных в конкурентных СУБД](#second)
### [3. Решение для данного кейса](#third)

<a name="first"></a>
## 1. Требования к реализации функции прогрева данных
### 1.1. ACID:
Atomicity (атомарность) - никакая транзакция не должна фиксироваться в системе частично. 

Consistency (согласованность) - транзакция, достигающая своего завершения с фиксацией результатов, сохраняет согласованность базы данных. 

Isolation (изолированность) - во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат. 

Durability (надежность)  - независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу. 

### 1.2. Нефункциональные требования к реализации функции:

Отказоустойчивость - при загрузке данных на жесткий диск (или наоборот), в случае возникновения ошибок, остальные процессы и система не должны «падать».

Производительность - время прогрева должно быть оптимизировано, чтобы не вызывать задержек в обслуживании транзакций и аналитических запросов.

Масштабируемость (больше для OLAP транзакций) - OLTP транзакции ориентированы на небольшой массив данных, при этом решение должно поддерживать увеличение объёма данных и нагрузки без значительного ухудшения работы.

Безопасность - доступ к функциям прогрева данных должен быть ограничен правами, чтобы избежать воздействия со стороны.

<a name="second"></a>
## 2. Анализ реализации функции прогрева данных в конкурентных СУБД
### 2.1. PostgreSQL (pg_prewarm) - предварительная загрузка данных отношений в кеш буферов

Модуль _pg_prewarm_ предоставляет удобный способ загрузки данных отношений в буферный кэш операционной системы или буферный кэш PostgreSQL.

Загрузка данных для прогрева: 
Вручную - использование функции pg_prewarm.
Автоматически - _pg_prewarm_ в параметр _shared_preload_libraries_. 

Система запустит фоновый процесс, который будет регулярно записывать содержимое разделяемых буферов в файл _autoprewarm.blocks_.

Для параметра _mode_ (метод «разогрева») существует 3 режима работы:

- _prefetch_ - в этом режиме операционной системе выдаются асинхронные запросы предвыборки данных, если они поддерживаются, иначе происходит ошибка;
- _read_ - в этом режиме считывается заданный диапазон блоков; считывание происходит синхронно и поддерживается во всех ОС любыми сборками; может выполняться медленнее _prefetch_ и _buffer_;
- _buffer_ - в этом режиме запрошенный диапазон блоков считывается в кеш буферов базы данных;

Ограничения: наиболее прогрев данных эффективен, когда кэш хранилище пусто. При желании обработать больше блоков базы данных, происходит вытеснение прогретых данных из памяти ОС после чтения (при использовании любого метода - _prefetch_, _read_, _buffer_)

### 2.2. SAP Hana (preload table) 

В SAP Hana для прогрева данных предусмотрен механизм предварительной загрузки таблиц, позволяющий заранее «поднимать» данные в хранилище в оперативной памяти после появления каких - либо запросов (также для прогрева данных требуется  перезапуск индексного сервера).


Возможны два варианта предварительной загрузки:

- _preaload all_ - загружает в память всю таблицу целиком, включая все столбцы.
- _preload (список_колонок)_ - предварительная загрузка только выбранных колонок.

Варианты использования для таблиц с индексами:

- _ALTER TABLE "schema"."table" PRELOAD ALL_ - для всех столбцов;
- _ALTER TABLE "schema"."table" PRELOAD (column_list)_ - отдельные колонки;

Ограничение: При этом список предварительно загружаемых таблиц и столбцов задаётся вручную и остаётся неизменным - он не корректируется на основе статистики выполнения запросов.

### 2.3. Apache Ignite (использование скриптов ignite.sh или ignite.bat)

Благодаря _Ignite_ способен обеспечить молниеносный доступ к данным, распределённым по горизонтально масштабируемому кластеру. Реализуется на основе _LoadAllWarmUpConfiguration_.

Стратегии прогрева данных: 

- _read-through_ предполагает, что при запросе данных, которых нет в кэше, кэш автоматически загружает данные из БД и сохраняет их в кэше для будущих запросов.
- _write-through_ обеспечивает синхронизацию данных с базой данных в реальном времени при их изменении в кэше.
- _cache-aside_ требует, чтобы приложение самостоятельно управляло загрузкой данных в кэш и их обновлением. 

Ограничение: отсутствует автоматическая и гибкая механика прогрева и синхронизации с базой, присутствует риск ошибок.

### 2.4. Redis (cache:warm)

Команда _cache:warm_ призвана решить проблему доступа к локальным данным путём предварительной загрузки важной информации в кэш Redis.

Ключевые принципы работы: 

- Изменение команды под новый _FlagCacheRepository_ для синхронизации с Redis. Команда будет получать данные из источника (например, API или базы данных) и преобразовывать их в формат, ожидаемый Redis.

- Учитывание сигнатуры ключей и настройки времени жизни (TTL), введённые в соответствующем обновлении (соглашения об именовании, используемые для идентификации данных в Redis, иначе говоря как долго данные будут храниться в кэше).

- Добавление интеграционного покрытия. После выполнения cache:warm тесты должны подтвердить, что при последующей оценке флагов функций данные будут извлекаться из кэша Redis, а не из внешнего источника.

Ограничения: краткосрочная несогласованность (в некоторой степени проблему можно решить, контролируя время жизни TTL). В таком случае значение пользовательского запроса может сохраняться как _null_ в памяти, при этом он существует в ней (то есть значение не «пустое»). 

<a name="third"></a>
## 3. Решение для данного кейса
Механизм прогрева данных для Tarantool должен представлять собой уникальный подход к обработке данных по сравнению с конкурентными СУБД. 

Основой надежности остается журнал предзаписи (WAL), гарантирующий сохранность данных при переносе на диск. 

Для скорости система следует использовать автоматическую предзагрузку в RAM, подобно реализации фичи в СУБД - PostgreSQL.

Сконцентрироваться лучше на внедрении многоуровневой системы приоритетов на основе используемости данных вместо удаления по сроку. Алгоритм будет динамически классифицировать данные на «горячие», «теплые» и «холодные», опираясь на частоту обращения, а не только на время. 

Стоит разработать небольшую ML - модель для прогнозирования запросов и потребности в данных до того, как произойдут пользовательские транзакции, что повлияет на работоспособность и быстроту ответа прогрева данных. 

Имеющийся _memtx_, созданный Tarantool, содержит в себе также репликацию данных из WAL и очищает для него места в случае ненадобности. Для универсальности и повышения надежности спектр ORM будет расширен, предоставив разработчикам на разных языках программирования возможность управлять данными.




